# Doc-Doctor 前后端开发说明

本文档面向前端开发者和 C++ 后端开发者，说明如何与现有服务层对接。

---

## 一、前端开发说明

### 1.1 前端代码位置

前端代码分为两个文件：
- **HTML 模板**：`src/extension.ts` 中的 `getHtmlForWebview()` 方法（第 47-119 行）
- **JavaScript 脚本**：`media/sidebar.js`

### 1.2 如何编辑前端界面

#### 修改 HTML 结构

在 `src/extension.ts` 的 `getHtmlForWebview()` 方法中修改 HTML：

```typescript
private getHtmlForWebview(webview: vscode.Webview): string {
  // ...
  return `<!DOCTYPE html>
    <html lang="zh-cn">
    <head>
      <!-- 样式定义 -->
      <style>
        /* 这里添加自定义样式 */
      </style>
    </head>
    <body>
      <!-- 在这里添加/修改界面元素 -->
      <button id="my-button">我的按钮</button>
      <div id="output">输出区</div>
      
      <script nonce="${nonce}" src="${scriptUri}"></script>
    </body>
    </html>`;
}
```

**注意事项：**
- 使用 VS Code CSS 变量（如 `var(--vscode-button-background)`）保持主题一致性
- 所有按钮/输入框必须设置唯一的 `id` 属性，以便在 JS 中引用
- 不要在 HTML 中写内联 JS（会被 CSP 拦截），所有逻辑写在 `sidebar.js` 中

#### 修改 JavaScript 逻辑

在 `media/sidebar.js` 中添加交互逻辑：

```javascript
(function () {
  const vscode = acquireVsCodeApi();
  
  // 1. 获取 HTML 元素
  const myButton = document.getElementById('my-button');
  const output = document.getElementById('output');
  
  // 2. 添加事件监听
  if (myButton) {
    myButton.addEventListener('click', function () {
      output.textContent = '正在处理...';
      // 向服务层发送消息（见 1.3）
      vscode.postMessage({ type: 'myCommandType', data: '额外数据' });
    });
  }
  
  // 3. 接收服务层返回的结果（见 1.4）
  window.addEventListener('message', function (event) {
    const message = event.data;
    if (message?.type === 'myResultType') {
      // 处理结果...
    }
  });
})();
```

---

### 1.3 前端如何调用服务层函数

前端通过 **`vscode.postMessage()`** 向服务层发送消息：

```javascript
vscode.postMessage({
  type: 'messageType',  // 消息类型（必须）
  data: { /* 额外数据 */ }  // 可选的数据字段
});
```

**消息类型（type）** 是服务层识别调用哪个函数的关键。

---

### 1.4 服务层提供的可调用函数

服务层通过监听消息类型来触发不同的函数。当前已支持的消息类型：

| 消息类型（type）           | 对应服务层函数                  | 功能说明                   |
| -------------------------- | ------------------------------- | -------------------------- |
| `runSingleFileCheck`       | `pickAndCheckFile()`            | 检查单个 C/C++ 文件        |
| `runProjectCheck`          | `runProjectCheck()`             | 检查整个项目所有文件       |
| `testJumpToLocation`       | `testJumpToLocation()`          | 测试跳转到指定位置         |
| `testSaveToDatabase`       | `testSaveToDatabase()`          | 测试存储问题到数据库       |
| `testLoadFromDatabase`     | `testLoadFromDatabase()`        | 测试从数据库读取问题列表   |

**示例：调用"检查整个项目"功能**

```javascript
// 前端发送消息
vscode.postMessage({ type: 'runProjectCheck' });
```

服务层在 `src/extension.ts` 的 `onDidReceiveMessage` 中处理：

```typescript
webviewView.webview.onDidReceiveMessage(async (message) => {
  switch (message?.type) {
    case "runProjectCheck":
      await runProjectCheck(webviewView.webview);  // 调用服务层函数
      break;
    // ...其他 case
  }
});
```

---

### 1.5 前端如何接收服务层返回的数据

服务层通过 **`webview.postMessage()`** 向前端发送结果：

```typescript
// 服务层发送结果（在 src/modules/ 中的各个模块）
webview?.postMessage({
  type: 'resultType',  // 结果类型
  result: { /* 结果数据 */ }
});
```

前端在 `sidebar.js` 中监听 `message` 事件接收：

```javascript
window.addEventListener('message', function (event) {
  const message = event.data;
  
  switch (message?.type) {
    case 'singleFileCheckResult':
      handleSingleFileCheckResult(message);
      break;
    case 'projectCheckResult':
      handleProjectCheckResult(message);
      break;
    // ...其他结果类型
  }
});
```

#### 各模块返回的数据格式

##### 1. 单文件检查结果 (`singleFileCheckResult`)

```javascript
{
  type: 'singleFileCheckResult',
  filePath: 'src/main.c',  // 文件路径
  result: {
    success: true,  // 是否成功
    functions: [    // 解析到的函数列表
      {
        functionName: 'main',
        functionSignature: 'int main(int argc, char* argv[])',
        lineNumber: 10,
        columnNumber: 5,
        comment: '/** @brief 主函数 */',  // Doxygen 注释
        functionContent: 'int main(...) { ... }'
      }
    ],
    // 如果失败：
    errorCode: 'FILE_NOT_FOUND',
    error: '文件不存在'
  }
}
```

##### 2. 项目检查结果 (`projectCheckResult`)

```javascript
{
  type: 'projectCheckResult',
  result: {
    totalFiles: 10,      // 总文件数
    checkedFiles: 8,     // 已检查文件数
    skippedFiles: ['src/large.c'],  // 跳过的文件列表
    problems: [          // 发现的问题列表
      {
        problemType: 3,  // 问题类型（1=参数缺失, 2=返回值缺失, 3=@brief缺失, 4=内容变更, 5=语法错误）
        filePath: 'src/utils.c',
        functionName: 'add',
        functionSignature: 'int add(int a, int b)',
        lineNumber: 25,
        columnNumber: 5,
        problemDescription: '缺少函数功能描述（@brief）',
        functionSnippet: 'int add(int a, int b) { ... }'
      }
    ],
    errorMessage: null  // 如果有错误，这里会有错误信息
  }
}
```

##### 3. 跳转结果 (`jumpToLocationResult`)

```javascript
{
  type: 'jumpToLocationResult',
  success: true,       // 是否跳转成功
  filePath: 'src/main.c',
  lineNumber: 10,
  columnNumber: 5
}
```

##### 4. 数据库存储结果 (`databaseSaveResult`)

```javascript
{
  type: 'databaseSaveResult',
  result: {
    success: true,     // 是否存储成功
    message: '问题已成功存储到数据库',
    insertedId: 123    // 插入的记录 ID（可选）
  }
}
```

##### 5. 数据库读取结果 (`databaseLoadResult`)

```javascript
{
  type: 'databaseLoadResult',
  result: {
    success: true,
    message: '成功读取 2 条记录',
    problems: [        // 数据库中的问题记录
      {
        id: 1,         // 数据库记录 ID
        problemType: 3,
        filePath: 'src/main.c',
        functionName: 'main',
        functionSignature: 'int main(int argc, char* argv[])',
        lineNumber: 10,
        columnNumber: 5,
        problemDescription: '缺少函数功能描述（@brief）',
        functionSnippet: 'int main(...) { ... }',
        checkTimestamp: '2025-12-22T10:30:00.000Z',  // 检查时间
        status: 0      // 状态（0=正常, 1=已忽略）
      }
    ]
  }
}
```

---

### 1.6 添加新功能的完整流程

假设要添加一个"清空数据库"功能：

#### 步骤 1：在服务层实现函数

在 `src/modules/database.ts` 中添加：

```typescript
export async function clearDatabase(webview?: vscode.Webview): Promise<void> {
  try {
    // 调用 C++ 删除数据
    // const result = await callCppClearDatabase();
    
    webview?.postMessage({
      type: 'clearDatabaseResult',
      result: { success: true, message: '数据库已清空' }
    });
  } catch (error) {
    webview?.postMessage({
      type: 'clearDatabaseResult',
      result: { success: false, message: '清空失败' }
    });
  }
}
```

#### 步骤 2：在 extension.ts 中注册消息处理

在 `src/extension.ts` 的 `onDidReceiveMessage` 中添加：

```typescript
import { clearDatabase } from "./modules/database";  // 导入

// 在 switch 中添加 case
case "clearDatabase":
  await clearDatabase(webviewView.webview);
  break;
```

#### 步骤 3：在 HTML 中添加按钮

在 `getHtmlForWebview()` 的 HTML 中添加：

```html
<button id="clear-db">清空数据库</button>
```

#### 步骤 4：在 sidebar.js 中添加事件监听和结果处理

```javascript
// 获取按钮
const btnClearDB = document.getElementById('clear-db');

// 添加点击事件
if (btnClearDB) {
  btnClearDB.addEventListener('click', function () {
    if (confirm('确定要清空数据库吗？')) {
      vscode.postMessage({ type: 'clearDatabase' });
    }
  });
}

// 在 message 监听器的 switch 中添加
case 'clearDatabaseResult':
  if (message.result.success) {
    output.textContent = '✅ ' + message.result.message;
  } else {
    output.textContent = '❌ ' + message.result.message;
  }
  break;
```

---

## 二、C++ 后端开发说明

### 2.1 后端职责

C++ 后端负责数据库的实际操作（使用 SQLite3），包括：
- 存储问题记录到数据库
- 从数据库读取问题记录
- 更新问题状态
- 删除/清空记录

### 2.2 数据库表结构

数据库文件位置：`<workspaceFolder>/doc-doctor/database/problems.db`

**表名：`problems`**

| 字段名                | 类型    | 说明                                               |
| --------------------- | ------- | -------------------------------------------------- |
| `id`                  | INTEGER | 主键，自增                                         |
| `problem_type`        | INTEGER | 问题类型（1-5，见下表）                            |
| `file_path`           | TEXT    | 文件路径（相对于工作区）                           |
| `function_signature`  | TEXT    | 函数签名（如 `int add(int a, int b)`）            |
| `function_name`       | TEXT    | 函数名                                             |
| `line_number`         | INTEGER | 函数所在行号                                       |
| `column_number`       | INTEGER | 函数所在列号                                       |
| `problem_description` | TEXT    | 问题描述（如"缺少参数 a 的说明"）                  |
| `function_snippet`    | TEXT    | 函数代码片段（前 200 字符）                        |
| `check_timestamp`     | TEXT    | 检查时间（ISO 8601 格式）                          |
| `status`              | INTEGER | 问题状态（0=正常，1=已忽略）                       |

**问题类型（problem_type）枚举：**

| 值  | 含义                   |
| --- | ---------------------- |
| 1   | 参数说明缺失           |
| 2   | 返回值说明缺失         |
| 3   | 函数功能说明缺失       |
| 4   | 内容变更警告           |
| 5   | 语法错误               |

---

### 2.3 C++ 需要实现的函数接口

#### 函数 1：存储单个问题

```cpp
/**
 * 存储单个问题到数据库
 * 
 * @param json_input - JSON 格式的问题数据（见下方示例）
 * @return 插入的记录 ID（失败返回 -1）
 */
extern "C" int saveProblem(const char* json_input);
```

**输入 JSON 格式：**

```json
{
  "problem_type": 3,
  "file_path": "src/main.c",
  "function_signature": "int main(int argc, char* argv[])",
  "function_name": "main",
  "line_number": 10,
  "column_number": 5,
  "problem_description": "缺少函数功能描述（@brief）",
  "function_snippet": "int main(int argc, char* argv[]) { ... }",
  "check_timestamp": "2025-12-22T10:30:00.000Z",
  "status": 0
}
```

**返回值：**
- 成功：返回插入的记录 ID（> 0）
- 失败：返回 -1

**实现要点：**
1. 使用 JSON 解析库（如 `nlohmann/json`）解析输入
2. 使用 SQLite3 API 插入数据
3. 使用 `sqlite3_last_insert_rowid()` 获取插入的 ID

---

#### 函数 2：读取所有问题

```cpp
/**
 * 从数据库读取所有问题记录
 * 
 * @return JSON 格式的问题列表（见下方示例）
 */
extern "C" const char* loadAllProblems();
```

**输出 JSON 格式：**

```json
[
  {
    "id": 1,
    "problem_type": 3,
    "file_path": "src/main.c",
    "function_signature": "int main(int argc, char* argv[])",
    "function_name": "main",
    "line_number": 10,
    "column_number": 5,
    "problem_description": "缺少函数功能描述（@brief）",
    "function_snippet": "int main(...) { ... }",
    "check_timestamp": "2025-12-22T10:30:00.000Z",
    "status": 0
  },
  {
    "id": 2,
    "problem_type": 1,
    "file_path": "src/utils.c",
    "function_name": "add",
    "function_signature": "int add(int a, int b)",
    "line_number": 25,
    "column_number": 5,
    "problem_description": "缺少参数 \"a\" 的说明（@param a）",
    "function_snippet": "int add(int a, int b) { return a + b; }",
    "check_timestamp": "2025-12-22T10:35:00.000Z",
    "status": 0
  }
]
```

**实现要点：**
1. 查询数据库所有记录：`SELECT * FROM problems`
2. 将结果转换为 JSON 数组
3. 返回的字符串指针需要由 TS 侧负责释放（或使用静态缓冲区）

---

### 2.4 TS 侧如何调用 C++ 函数

TS 侧将使用 `ffi-napi` 或 `node-addon-api` 调用动态库：

```typescript
// src/modules/database.ts 中的 TODO 部分

import ffi from 'ffi-napi';
import path from 'path';

// 加载动态库
const dllPath = path.join(__dirname, '../../native/database.dll');  // Windows
// const dllPath = path.join(__dirname, '../../native/database.so');  // Linux

const nativeLib = ffi.Library(dllPath, {
  'saveProblem': ['int', ['string']],
  'loadAllProblems': ['string', []]
});

// 调用示例
export async function saveProblemToDB(problemInfo: ProblemInfo): Promise<SaveResult> {
  const jsonString = JSON.stringify({
    problem_type: problemInfo.problemType,
    file_path: problemInfo.filePath,
    function_signature: problemInfo.functionSignature,
    function_name: problemInfo.functionName,
    line_number: problemInfo.lineNumber,
    column_number: problemInfo.columnNumber,
    problem_description: problemInfo.problemDescription,
    function_snippet: problemInfo.functionSnippet,
    check_timestamp: new Date().toISOString(),
    status: ProblemStatus.NORMAL
  });
  
  const insertedId = nativeLib.saveProblem(jsonString);
  
  if (insertedId > 0) {
    return { success: true, message: '存储成功', insertedId };
  } else {
    return { success: false, message: '存储失败' };
  }
}
```

---

### 2.5 C++ 项目结构建议

```
doc-doctor/
├── native/                   # C++ 代码目录
│   ├── src/
│   │   ├── database.cpp      # 数据库操作实现
│   │   ├── database.h        # 头文件
│   │   └── main.cpp          # 测试用例
│   ├── CMakeLists.txt        # CMake 配置
│   └── build/                # 编译输出目录
│       ├── database.dll      # Windows 动态库
│       └── database.so       # Linux 动态库
└── src/
    └── modules/
        └── database.ts       # TS 桥接层（调用 C++ 函数）
```

### 2.6 编译命令示例

**使用 CMake：**

```bash
cd native
mkdir build && cd build
cmake ..
cmake --build . --config Release
```

**直接使用 g++（Linux）：**

```bash
g++ -shared -fPIC -o database.so database.cpp -lsqlite3 -std=c++17
```

**使用 MSVC（Windows）：**

```cmd
cl /LD /EHsc database.cpp sqlite3.lib /Fe:database.dll
```

---

### 2.7 C++ 依赖库

- **SQLite3**：数据库操作
- **nlohmann/json**（推荐）：JSON 解析/生成

安装方式：
```bash
# Ubuntu/Debian
sudo apt-get install libsqlite3-dev

# macOS
brew install sqlite3

# Windows
# 从 https://www.sqlite.org/download.html 下载预编译库
```

---

### 2.8 C++ 实现示例（伪代码）

```cpp
#include <sqlite3.h>
#include <nlohmann/json.hpp>
#include <string>

using json = nlohmann::json;

sqlite3* db = nullptr;

// 初始化数据库（创建表）
void initDatabase(const char* dbPath) {
    sqlite3_open(dbPath, &db);
    
    const char* createTableSQL = R"(
        CREATE TABLE IF NOT EXISTS problems (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            problem_type INTEGER,
            file_path TEXT,
            function_signature TEXT,
            function_name TEXT,
            line_number INTEGER,
            column_number INTEGER,
            problem_description TEXT,
            function_snippet TEXT,
            check_timestamp TEXT,
            status INTEGER
        )
    )";
    
    sqlite3_exec(db, createTableSQL, nullptr, nullptr, nullptr);
}

// 存储问题
extern "C" int saveProblem(const char* json_input) {
    auto j = json::parse(json_input);
    
    const char* insertSQL = R"(
        INSERT INTO problems (problem_type, file_path, function_signature, 
                              function_name, line_number, column_number,
                              problem_description, function_snippet, 
                              check_timestamp, status)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    )";
    
    sqlite3_stmt* stmt;
    sqlite3_prepare_v2(db, insertSQL, -1, &stmt, nullptr);
    
    sqlite3_bind_int(stmt, 1, j["problem_type"]);
    sqlite3_bind_text(stmt, 2, j["file_path"].get<std::string>().c_str(), -1, SQLITE_TRANSIENT);
    // ... 绑定其他参数
    
    sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    
    return sqlite3_last_insert_rowid(db);
}

// 读取所有问题
extern "C" const char* loadAllProblems() {
    json result = json::array();
    
    const char* selectSQL = "SELECT * FROM problems";
    sqlite3_stmt* stmt;
    sqlite3_prepare_v2(db, selectSQL, -1, &stmt, nullptr);
    
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        json problem;
        problem["id"] = sqlite3_column_int(stmt, 0);
        problem["problem_type"] = sqlite3_column_int(stmt, 1);
        problem["file_path"] = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2));
        // ... 读取其他字段
        
        result.push_back(problem);
    }
    
    sqlite3_finalize(stmt);
    
    static std::string resultStr = result.dump();
    return resultStr.c_str();
}
```

---

## 三、开发流程总结

### 前端开发者：
1. 在 `extension.ts` 中修改 HTML 结构
2. 在 `sidebar.js` 中添加按钮事件监听和结果处理函数
3. 通过 `vscode.postMessage()` 调用服务层
4. 通过 `window.addEventListener('message')` 接收结果

### 服务层开发者（当前已完成）：
1. 在 `src/modules/` 中实现业务逻辑
2. 在 `extension.ts` 中注册消息处理
3. 通过 `webview.postMessage()` 返回结果

### C++ 后端开发者：
1. 实现 SQLite 数据库操作
2. 提供 `saveProblem()` 和 `loadAllProblems()` 接口
3. 使用 JSON 格式与 TS 层通信
4. 编译为动态库（.dll / .so）

---

## 四、常见问题

### Q1: 如何调试前端代码？
**A:** 按 F5 启动扩展调试，打开侧边栏后按 `Ctrl+Shift+P` 输入 "Developer: Open Webview Developer Tools" 查看控制台。

### Q2: 前端修改后不生效？
**A:** 重新加载窗口（`Ctrl+R`）或重启扩展（F5 重新调试）。

### Q3: C++ 如何返回错误信息？
**A:** 在 JSON 中添加 `error` 字段：
```json
{ "success": false, "message": "数据库连接失败", "error": "..." }
```

### Q4: 数据库文件存放在哪里？
**A:** `<当前工作区根目录>/doc-doctor/database/problems.db`

### Q5: 如何处理大量数据？
**A:** 可以添加分页接口：
```cpp
extern "C" const char* loadProblemsWithPagination(int page, int pageSize);
```

---

## 五、联系方式

如有疑问，请联系服务层开发者或查看代码注释。

**服务层代码位置：**
- 文件检查：`src/modules/fileCheck.ts`
- 函数检查：`src/modules/functionCheck.ts`
- 项目检查：`src/modules/projectCheck.ts`
- 跳转功能：`src/modules/jumpToLocation.ts`
- 数据库桥接：`src/modules/database.ts`
