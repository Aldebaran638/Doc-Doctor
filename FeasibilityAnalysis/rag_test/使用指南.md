### 核心思路：代码解析 + 向量数据库

我们将把这个问题分为两个阶段：

1.  **索引阶段 (Indexing)**：扫描整个项目，将每个函数解析出来，转换成可以被“理解”和“搜索”的格式（即**向量**），并存入一个数据库。
2.  **查询阶段 (Querying)**：接收用户输入的函数，同样将其转换为向量，然后去数据库中搜索最相似的向量，这些向量对应就是相关的函数。

---

### 详细技术步骤和所需库

#### 步骤 1：项目设置和安装依赖

首先，创建一个新的 Node.js + TypeScript 项目。

```bash
mkdir function-analyzer
cd function-analyzer
npm init -y
npm install typescript @types/node ts-node --save-dev
# 初始化 tsconfig.json
npx tsc --init
```

然后，安装我们将要用到的核心库：

```bash
# 1. 代码解析器 (用于从代码中提取函数)
npm install tree-sitter tree-sitter-cpp tree-sitter-javascript # 以C++和JS为例

# 2. 向量嵌入生成 (将文本转换为向量)
npm install @xenova/transformers

# 3. 向量数据库 (用于存储和搜索向量)
npm install hnswlib-node # 一个高性能的本地向量数据库
```

#### 步骤 2：索引整个项目 (Indexing Phase)

创建一个名为 `indexer.ts` 的文件。这个文件的任务是遍历你项目中的所有代码文件，提取出所有函数，并将它们向量化后存起来。

```typescript
// indexer.ts
import fs from 'fs/promises';
import path from 'path';
import Parser from 'tree-sitter';
import Cpp from 'tree-sitter-cpp';
import { pipeline } from '@xenova/transformers';
import { HierarchicalNSW } from 'hnswlib-node';

// --- 1. 初始化 ---
const parser = new Parser();
// 根据你的目标语言设置解析器
parser.setLanguage(Cpp); 

// 加载嵌入模型 (只会下载一次)
const extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');

// 初始化向量数据库
const index = new HierarchicalNSW('l2', 384); // 384是模型的维度

// --- 2. 函数提取 ---
async function extractFunctions(filePath: string): Promise<{ name: string; code: string }[]> {
    const code = await fs.readFile(filePath, 'utf-8');
    const tree = parser.parse(code);
    const functions: { name: string; code: string }[] = [];

    // 使用Tree-sitter查询来捕获函数定义
    const query = new Parser.Query(Cpp, '(function_definition) @func');
    const matches = query.matches(tree.rootNode);

    for (const match of matches) {
        const node = match.captures[0].node;
        const functionNameNode = node.childForFieldName('declarator')?.childForFieldName('declarator');
        
        if (functionNameNode) {
            const functionName = code.substring(functionNameNode.startIndex, functionNameNode.endIndex);
            const functionCode = node.text;
            functions.push({ name: functionName, code: functionCode });
        }
    }
    return functions;
}

// --- 3. 主索引逻辑 ---
async function runIndexer(projectPath: string) {
    console.log('开始索引项目...');
    const allFiles = await fs.readdir(projectPath); // 简化版，实际需要递归遍历
    const functionMetadatas: { filePath: string; name: string }[] = [];

    for (const file of allFiles) {
        if (file.endsWith('.cpp')) { // 只处理C++文件
            const filePath = path.join(projectPath, file);
            const functions = await extractFunctions(filePath);

            for (const func of functions) {
                // 生成向量嵌入
                const embedding = await extractor(func.code, { pooling: 'mean', normalize: true });
                
                // 将向量添加到数据库
                index.addPoint(Array.from(embedding.data as Float32Array), functionMetadatas.length);
                
                // 存储元数据（用于后续查找）
                functionMetadatas.push({ filePath, name: func.name });
            }
        }
    }

    // 保存索引和元数据
    await index.writeIndex('functions.index');
    await fs.writeFile('functions.meta.json', JSON.stringify(functionMetadatas));
    
    console.log(`索引完成！共索引了 ${functionMetadatas.length} 个函数。`);
}

// 运行索引器
// runIndexer('d:/path/to/your/project');
```

#### 步骤 3：查询相关函数 (Querying Phase)

现在创建 `query.ts` 文件。它负责加载索引，并对给定的函数代码进行搜索。

```typescript
// query.ts
import fs from 'fs/promises';
import { pipeline } from '@xenova/transformers';
import { HierarchicalNSW } from 'hnswlib-node';

// --- 1. 加载模型、索引和元数据 ---
const extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
const index = new HierarchicalNSW('l2', 384);
await index.readIndex('functions.index');
const functionMetadatas = JSON.parse(await fs.readFile('functions.meta.json', 'utf-8'));

// --- 2. 查询函数 ---
export async function findRelatedFunctions(inputFunctionCode: string, topK: number = 5) {
    console.log('正在查找相关函数...');

    // 1. 将输入函数转换为向量
    const queryEmbedding = await extractor(inputFunctionCode, { pooling: 'mean', normalize: true });
    const queryVector = Array.from(queryEmbedding.data as Float32Array);

    // 2. 在向量数据库中搜索最相似的 K 个邻居
    const result = index.searchKnn(queryVector, topK);

    // 3. 格式化并返回结果
    const relatedFunctions = result.neighbors.map((neighborIndex, i) => {
        const metadata = functionMetadatas[neighborIndex];
        return {
            filePath: metadata.filePath,
            functionName: metadata.name,
            similarity: 1 - result.distances[i] / 2 // 将距离转换为相似度 (0-1)
        };
    });

    return relatedFunctions;
}

// --- 示例用法 ---
async function main() {
    const myFunctionCode = `
    int calculate_sum(int a, int b) {
        return a + b;
    }
    `;
    const related = await findRelatedFunctions(myFunctionCode);
    console.log('输入函数可能与以下函数相关:');
    console.table(related);
}

// main();
```

### 总结：你使用的 RAG 核心库

要实现这个功能，你主要依赖以下三类库，它们共同构成了 RAG 的检索流程：

1.  **代码解析库 (Code Parser)**
    *   **库**: `tree-sitter`
    *   **作用**: 像编译器一样“阅读”你的代码，把它从纯文本变成结构化的语法树 (AST)。这使得你可以精确地提取出函数、变量、注释等元素。这是**检索的第一步：识别出要被索引的对象**。

2.  **向量嵌入模型库 (Embedding Model)**
    *   **库**: `@xenova/transformers`
    *   **作用**: 这是 RAG 的魔法核心。它能将任何文本（比如你的函数代码）转换成一个由几百个数字组成的列表（即“向量”）。这个向量代表了文本的**语义含义**。功能相似但代码不同的两个函数，它们的向量在空间中的距离会非常近。

3.  **向量数据库 (Vector Database)**
    *   **库**: `hnswlib-node` (本地) 或云服务如 Pinecone, ChromaDB。
    *   **作用**: 一个专门为存储和**高速搜索**向量而设计的数据库。当你给它一个查询向量时，它能以极快的速度告诉你“距离最近”的其他向量是哪些，从而帮你**完成智能检索**。

通过组合这三者，你就能构建一个强大的、基于语义的代码相关性分析工具。